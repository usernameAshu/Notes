{\rtf1\ansi\ansicpg1252\cocoartf2821
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10960\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs36 \cf0 Hash Table Internals
\fs26 \
\

\f1\b0 Constant time - \
Insertions\
Deletions\
Lookups\
\
Two ideas to construct Hash Table:\
1.
\f0\b  Application key to hash key [0,N]
\f1\b0 \
Ex: apple -> 12344534\
2.
\f0\b  Map Hash key to a smaller range [0,m]
\f1\b0 \
12344534 -> 17\
\
A naive solution can be to directly use the has-key in step 1 , and use a gigantic array to store at that place. This works if the hash value is small. If it\'92s big like a 32-bit integer, then it would require huge amount of storage. \
Also, since array is a contiguous space in memory, there would be huge wastage of memory where the array index is empty. \

\f0\b Challenges:\
1. Finding this big chunk of memory is tough \
2. Lot of slots would remain empty.\
\

\f1\b0 Why hashing String to int ?\
Since first step allows us to give more abstraction, and also simplifying our problem in 2nd step.\
So, hash table is agnostic of the type of the key.\
\
Since object -> INT32 \
It enables us to store complex objects as key. \
\

\f0\b Resizing of Hash Table \
\

\f1\b0 Expensive operation but a one-time when alpha (load factor) reaches threshold \
Time taken to resize is proportional to the number of keys \
\
A typical strategy is to double the array \
Old distribution: h(k) % m_old\
New Distribution: h(k) % m_new\
m_old : old size, m_new : new size \
\
Whenever the capacity reaches the load factor the hash table doubles on it\'92s size \
Hash Table has 2^N slots for faster compute (doing bitwise on N-1 )\
HashTables grows when load factor is 1/2 \
It shrinks when load factor is 1/8\

\f0\b \
}